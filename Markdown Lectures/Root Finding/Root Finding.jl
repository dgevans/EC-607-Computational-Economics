using Gadfly
## Fixed point iteration
g(x) = 2-1.5/(1+x)
x0 = 0.25
diff = 1.
while diff > 1e-6
    global x0
    x1 = g(x0)
    diff = abs(x1 - x0)
    x0 = x1
end
println("The fixed point is: $x0")

#Bisection method
f(x) = x - g(x)
a,b = 0.5,1.75
diff = 1
while diff > 1e-6
    global a,b
    c = (a+b)/2
    if f(c) > 0
        b = c
    else
        a = c
    end
    diff = b-a
end
println("Root is $((a+b)/2)")

## Newton's method
f(x) = x^3-.05
df(x) = 3*x^2
x0 = 1.
diff = 1.
while diff > 1e-6
    global diff,x0
    x1 = x0 - f(x0)/df(x0)
    x0 = x1
    diff = abs(x1-x0)
end
println("The root is $x0")


## Neo-Classical Example
using Parameters,Roots
@with_kw mutable struct NCParameters
    A::Float64 = 1.  #Productivity
    α::Float64 = 0.3 #Capital Share of Output
    β::Float64 = 0.96 #Discount Factor
    δ::Float64 = 0.1 #Depreciation Rate
    σ::Float64 = 2.  #1/IES
end

"""
    compute_steadystate(para::NCParameters)

Computes steady state given parameters stored in para
"""
function compute_steadystate(para::NCParameters)
    @unpack A,α,β,δ,σ = para
    R̄ = 1/β
    k̄ =((R̄ - 1 + δ)/(α * A))^(1/(α-1))

    c̄ = A*k̄^α - δ*k̄

    return c̄,k̄
end

para =NCParameters()
c̄,k̄ = compute_steadystate(para)

"""
    iterateEuler(para::NCParameters,c,k)

Computes consumption and capital next period that 
satisfies the Euler equation. 
"""
function iterateEuler(para::NCParameters,c,k)::Vector{Float64}
    @unpack A,α,β,δ,σ = para
    k′ = A*k^α + (1-δ)*k - c
    if k′ > 0 #check to see if k′ makes sense
        R′ = α*A*(k′)^(α-1) + 1 -δ

        c′ = (β*R′*c^σ)^(1/σ)
        return [c′,k′]  
    else
        return zeros(2)
    end
end

iterateEuler(para,c̄,k̄)

"""
    getshootingpath(para::NCParameters,c0,k0,T=100)

Computes the path generated by iterating on the Euler
equation for T periods
"""
function getshootingpath(para::NCParameters,c0,k0,T=100)
    k,c = zeros(T),zeros(T)
    c[1],k[1] = c0,k0
    for t in 1:T-1
        c[t+1],k[t+1] = iterateEuler(para,c[t],k[t])
    end

    return (c=c,k=k) #named tuple for easy access
end

plot(layer(y=getshootingpath(para,c̄+0.00001,k̄).k,Geom.line,color = ["High Initial C"]),
     layer(y=getshootingpath(para,c̄-0.00001,k̄).k,Geom.line,color = ["Low Initial C"]),
     Guide.xlabel("Time"),Guide.ylabel("Capital Stock"),Guide.colorkey(title=""))

"""
    findoptimal_c(para,k)

Finds the optimal consumption for a given level of capital.  Uses
shooting method with terminal T periods
"""
function findoptimal_c(para::NCParameters,k0,T=100)
    c̄,k̄ = compute_steadystate(para)
    #iterates on the Euler equation for T periods then returns 
    #capital relative to steady state
    function c_res(c0)
        c,k = iterateEuler(para,c0,k0)
        for t in 1:T
            c,k =  iterateEuler(para,c,k)
        end

        return k - k̄
    end

    #use bracketing
    fzero(c_res,(0.1*c̄,10*c̄))
end
println(findoptimal_c(para,k̄) - c̄)

plot(y=getshootingpath(para,findoptimal_c(para,k̄),k̄).k,Geom.line(),
    Guide.xlabel("Time"),Guide.ylabel("Capital Stock"))

k0=0.9*k̄
plot(y=getshootingpath(para,findoptimal_c(para,k0),k0).k,Geom.line(),
    Guide.xlabel("Time"),Guide.ylabel("Capital Stock"))

k0=1.1*k̄
plot(y=getshootingpath(para,findoptimal_c(para,k0),k0).k,Geom.line(),
    Guide.xlabel("Time"),Guide.ylabel("Capital Stock"))

##Multivariate Root solving
using NLsolve

#consider this function
f(x) = [(x[1]+3)*(x[2]^3-7)+18, sin(x[2]*exp(x[1])-1)];

res = nlsolve(f,[ 0.,0.])
println("Did the root solver converge: $(converged(res))")
println("What was the solution: $(res.zero)")
println("Check f at solution: $(f(res.zero))")


#Alternative changing values in place
function f!(fvec,x )
    fvec[1] = (x[1]+3)*(x[2]^3-7)+18
    fvec[2] = sin(x[2]*exp(x[1])-1)
end;
#NOTE: NEED DERIVATIVES TO BE EXACT!
function g!(fjac,x)
    fjac[1, 1] = x[2]^3-7
    fjac[1, 2] = 3*x[2]^2*(x[1]+3)
    u = exp(x[1])*cos(x[2]*exp(x[1])-1)
    fjac[2, 1] = x[2]*u
    fjac[2, 2] = u
end;

res = nlsolve(f!,g!,zeros(2))
println("Did the root solver converge: $(converged(res))")
println("What was the solution: $(res.zero)")
println("Check f at solution: $(f(res.zero))")


#compare speeds
@time nlsolve(f,zeros(2));
@time nlsolve(f!,g!,zeros(2));


## Neoclassical Model Take 2

"""
    capitalpath_residual(para,k0::Float64,k::Vector{Float64})

Computes the euler equation errors given a guess of k[t] = kpath[t]
for t <=T and k[t] = k̄ after.
"""
function capitalpath_residual(para::NCParameters,k0::Float64,kpath::Vector{Float64})
    @unpack A,α,β,δ,σ = para
    c̄,k̄ = compute_steadystate(para)
    T = length(kpath)
    k = [k0;kpath;k̄]
    #compute path of c given guess of k
    c = [A*k[t]^α + (1-δ)*k[t] - k[t+1] for t in 1:T+1]
    #compute path of R given guess of k
    R = [1-δ+α*A*k[t]^(α-1) for t in 1:T+1]
    uc = c.^(-σ)

    #compute Euler equation residuals
    return uc[1:T] .- β .* R[2:T+1].*uc[2:T+1]
end

"""
    solveMITshock(para::NCParameters,k0::Float64,T=100)

Finds the perfect forsight equilibrium for a given intial k0
"""
function solveMITshock(para::NCParameters,k0::Float64,T=100)
    @unpack A,α,β,δ,σ = para
    c̄,k̄ = compute_steadystate(para)
    kpath0 = collect(LinRange(k0,k̄,T))# guess a simple linear rule

    result = nlsolve(k->capitalpath_residual(para,k0,k),kpath0)
    if !converged(result)
        error("Could not find root!")
    end

    kpath = result.zero
    k = [k0;kpath;k̄]
    #compute path of c given guess of k
    c = [A*k[t]^α + (1-δ)*k[t] - k[t+1] for t in 1:T+1]

    return (c=c,k=k)
end

k0=0.9*k̄
plot(layer(y=solveMITshock(para,k0).k[1:100],Geom.line(),color=["Multivariate Solver"]),
     layer(y=getshootingpath(para,findoptimal_c(para,k0),k0).k,Geom.line(),color=["Shooting Algorithm"]),
    Guide.xlabel("Time"),Guide.ylabel("Capital Stock"),Guide.colorkey(title=""))

k0=1.1*k̄
plot(layer(y=solveMITshock(para,k0).k[1:100],Geom.line(),color=["Multivariate Solver"]),
     layer(y=getshootingpath(para,findoptimal_c(para,k0),k0).k,Geom.line(),color=["Shooting Algorithm"]),
    Guide.xlabel("Time"),Guide.ylabel("Capital Stock"),Guide.colorkey(title=""))







## DMP model
using QuantEcon,Parameters,DataFrames,Random

"""
An object containing all the model parameters for our DMP model,
with default values 0.99,0.212,0.72,0.4,0.05,0.72,0.83
"""
@with_kw mutable struct DMPModel
    β::Float64 = 0.99
    κ::Float64 = 0.212
    η::Float64 = 0.72
    b::Float64 = 0.4
    δ::Float64 = 0.05
    α::Float64 = 0.72
    A::Float64 = 0.83
    z::Vector{Float64}
    P::Matrix{Float64}
end

"""
DMPModel(Nz,ρ_z,σ_z) 

Constructs an instance of DMPModel from model parameters
"""
function DMPModel(Nz,ρ_z,σ_z)
    mc = rouwenhorst(Nz,ρ_z,σ_z)
    return DMPModel(z = exp.(mc.state_values), P = mc.p)
end

model = DMPModel(51,0.8,0.014)
println(model.β)
println(model.z)


p(dmp,θ) = dmp.A*θ.^(1-dmp.α) #note the .^
q(dmp,θ) = dmp.A*θ.^(-dmp.α)   

"""
    residuals(dmp::DMPModel,θvec)

Computes the residuals of the equilibrium conditions given θvec for a 
given set of parameters dmp
"""
function residuals(dmp::DMPModel,θvec)
    @unpack η,z,P,b,κ,δ,β = dmp
    S = length(z)
    qvec = q(dmp,θvec)
    #note @. means vectorize all operations
    rhs = @.((1-η)*(z -b) -η*κ*θvec+(1-δ)*κ/qvec)
    lhs = @.(κ/(β*qvec))
    return P*rhs -lhs
end

"""
    equilibrium(dmp::DMPModel)

Solves for the equilibrium of the DMP model with parameters in 
struct dmp
"""
function equilibrium(dmp::DMPModel)
    S = length(dmp.z)
    return nlsolve(x->residuals(dmp,x),ones(S)).zero
end

"""
    calibrate_κ!(dmp::DMPModel)

Internally calibrates κ to target an average θ of 1
"""
function calibrate_κ!(dmp::DMPModel)
    θvec0 = equilibrium(dmp) #first find the equilibrium for a given κ
    function res(κθvec)
        κ,θvec = κθvec[1],κθvec[2:end]
        dmp.κ = κ #note changing value form dmp
        return [1-(dmp.P^500*θvec)[1]; #long run θ is 1
                residuals(dmp,θvec)]#eqb residuals must be 0
    end
    κθvec0 = [dmp.κ;θvec] #

    dmp.κ =  nlsolve(res,κθvec0).zero[1]

    return equilibrium(dmp)
end

residuals(model,zeros(51))
θvec = equilibrium(model)
println(model.P^500*θvec)
θvec = calibrate_κ!(model)
println(model.P^500*θvec)

function simulate_economy(dmp,initial_state,T)
    @unpack δ,η,b,κ,δ = dmp
    s1,u1 = initial_state
    θvec = equilibrium(dmp)
    #preallocate space
    u,v,y,z,θ,w = zeros(T+1),zeros(T),zeros(T),zeros(T),zeros(T),zeros(T)
    u[1] = u1
    s = simulate_indices(MarkovChain(model.P),T,init=s1)
    for t in 1:T
        θ[t] = θvec[s[t]]
        z[t] = dmp.z[s[t]]
        y[t] = z[t]*(1-u[t])
        v[t] = θ[t]*u[t]
        w[t] = η*z[t] + (1-η)*b + η*κ*θ[t]
        u[t+1] = u[t]+δ*(1-u[t])-p(dmp,θ[t])*u[t]
    end
    #often convenient to return simulations as DataFrame
    return DataFrame(u=u[1:T],v=v,y=y,θ=θ,z=z,w=w)
end

df = simulate_economy(model,(25,0.057),200)
gridstack([plot(df,y=:u,Geom.line) plot(df,y=:v,Geom.line);
           plot(df,y=:w,Geom.line) plot(df,y=:θ,Geom.line)] )


function impulseResponse(dmp,u0,s0,s0′,T,N=100)
    
    #compute average path with initial state s0
    Random.seed!(4234345) #use the same random seed
    df_irf = simulate_economy(dmp,(s0,u0),T)
    for i in 2:N
        dftemp = simulate_economy(dmp,(s0,u0),T)
        df_irf .+= dftemp
    end
    df_irf ./= N 

    #compute average path with initial state s0′
    Random.seed!(4234345) #use the same random seed
    df_irf′ = simulate_economy(dmp,(s0′,u0),T)
    for i in 2:N
        df_irf′ .+= simulate_economy(dmp,(s0′,u0),T)
    end
    df_irf′ ./= N 

    #return difference
    return df_irf′ .- df_irf
end


df_irf = impulseResponse(model,0.057,25,30,20)

gridstack([plot(df_irf,y=:u,Geom.line) plot(df_irf,y=:v,Geom.line);
           plot(df_irf,y=:y,Geom.line) plot(df_irf,y=:θ,Geom.line)] )