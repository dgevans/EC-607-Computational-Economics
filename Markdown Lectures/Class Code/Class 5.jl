function test()
    #do work
    return (a=1,b=2)
end



## Neo-Classical Example
using Parameters,Roots
@with_kw mutable struct NCParameters
    A::Float64 = 1.  #Productivity
    α::Float64 = 0.3 #Capital Share of Output
    β::Float64 = 0.96 #Discount Factor
    δ::Float64 = 0.1 #Depreciation Rate
    σ::Float64 = 2.  #1/IES
end

"""
    compute_steadystate(para::NCParameters)

Computes steady state given parameters stored in para
"""
function compute_steadystate(para::NCParameters)
    @unpack A,α,β,δ,σ = para
    R̄ = 1/β
    k̄ =((R̄ - 1 + δ)/(α * A))^(1/(α-1))

    c̄ = A*k̄^α - δ*k̄

    return c̄,k̄
end

para =NCParameters()
c̄,k̄ = compute_steadystate(para)

"""
    iterateEuler(para::NCParameters,c,k)

Computes consumption and capital next period that 
satisfies the Euler equation. 
"""
function iterateEuler(para::NCParameters,c,k)::Vector{Float64}
    @unpack A,α,β,δ,σ = para
    k′ = A*k^α + (1-δ)*k - c
    if k′ > 0 #check to see if k′ makes sense
        R′ = α*A*(k′)^(α-1) + 1 -δ

        c′ = (β*R′*c^σ)^(1/σ)
        return [c′,k′]  
    else
        return zeros(2)
    end
end

iterateEuler(para,c̄,k̄)

"""
    getshootingpath(para::NCParameters,c0,k0,T=100)

Computes the path generated by iterating on the Euler
equation for T periods
"""
function getshootingpath(para::NCParameters,c0,k0,T=100)
    k,c = zeros(T),zeros(T)
    c[1],k[1] = c0,k0
    for t in 1:T-1
        c[t+1],k[t+1] = iterateEuler(para,c[t],k[t])
    end

    return (c=c,k=k) #named tuple for easy access
end

plot(layer(y=getshootingpath(para,c̄+0.00001,k̄,300).k,Geom.line,color = ["High Initial C"]),
     layer(y=getshootingpath(para,c̄-0.00001,k̄,300).k,Geom.line,color = ["Low Initial C"]),
     Guide.xlabel("Time"),Guide.ylabel("Consumption"),Guide.colorkey(title=""))



using NLsolve

#consider this function
h(x) = [(x[1]+3)*(x[2]^3-7)+18, sin(x[2]*exp(x[1])-1)];

res = nlsolve(h,[ 0.,0.])


#Note fvec is filled with function values
function f!(fvec,x )
    fvec[1] = (x[1]+3)*(x[2]^3-7)+18
    fvec[2] = sin(x[2]*exp(x[1])-1)
end;

#NOTE: NEED DERIVATIVES TO BE EXACT!
function g!(fjac,x)
    fjac[1, 1] = x[2]^3-7
    fjac[1, 2] = 3*x[2]^2*(x[1]+3)
    u = exp(x[1])*cos(x[2]*exp(x[1])-1)
    fjac[2, 1] = x[2]*u
    fjac[2, 2] = u
end;

res = nlsolve(f!,g!,zeros(2))
println("Did the root solver converge: $(converged(res))")
println("What was the solution: $(res.zero)")
println("Check f at solution: $(h(res.zero))")



"""
    capitalpath_residual(para,k0::Float64,k::Vector{Float64})

Computes the euler equation errors given a guess of k[t] = kpath[t]
for t <=T and k[t] = k̄ after.
"""
function capitalpath_residual(para::NCParameters,k0::Float64,kpath::Vector{Float64})
    @unpack A,α,β,δ,σ = para
    c̄,k̄ = compute_steadystate(para)
    T = length(kpath)
    k = [k0;kpath;k̄]
    #compute path of c given guess of k
    c = [A*k[t]^α + (1-δ)*k[t] - k[t+1] for t in 1:T+1]
    #compute path of R given guess of k
    R = [1-δ+α*A*k[t]^(α-1) for t in 1:T+1]
    uc = c.^(-σ)

    #compute Euler equation residuals
    return uc[1:T] .- β .* R[2:T+1].*uc[2:T+1]

    return [uc[t]-β*R[t+1]*uc[t+1] for t in 1:T]
end;


k0 = 0.9*k̄

kpath = collect(LinRange(k0,k̄,100))

@unpack A,α,β,δ,σ = para
c̄,k̄ = compute_steadystate(para)
T = length(kpath)
k = [k0;kpath;k̄]
#compute path of c given guess of k
c = [A*k[t]^α + (1-δ)*k[t] - k[t+1] for t in 1:T+1]
#same as
c = zeros(T+1)
for t in 1:T+1
    c[t] = A*k[t]^α + (1-δ)*k[t] - k[t+1]
end
#compute path of R given guess of k
R = [1-δ+α*A*k[t]^(α-1) for t in 1:T+1]
uc = c.^(-σ)